#include "structs/cassandra/renderers/spark_java_file.h"

#include <string>

#include "absl/strings/str_join.h"
#include "glog/logging.h"

#include "structs/base/code_builder.h"
#include "structs/cassandra/renderers/java_helpers.h"

namespace structs {
namespace {
string PathToField(const FieldGen& field) {
  return absl::StrJoin(field.path(), "_");
}

string JavaTypeOfCassandra(const string& cassandra_type) {
  std::map<string, string> types;
  types["timestamp"] = "java.util.Date";
  types["double"] = "double";
  types["float"] = "float";
  types["bigint"] = "long";
  types["varint"] = "java.math.BigInteger";
  types["int"] = "int";
  types["boolean"] = "boolean";
  types["text"] = "String";
  types["blob"] = "java.nio.ByteBuffer";

  auto it = types.find(cassandra_type);
  CHECK(it != types.end()) << "unsupported type: " << cassandra_type;
  return it->second;
}

std::string GetFromCassandraRow(const std::string cassandra_type) {
  std::map<std::string, std::string> types;
  types["timestamp"] = "getDate";
  types["double"] = "getDouble";
  types["float"] = "getFloat";
  types["bigint"] = "getLong";
  types["varint"] = "getVarInt";
  types["int"] = "getInt";
  types["boolean"] = "getBoolean";
  types["text"] = "getString";
  types["blob"] = "getBytes";

  auto it = types.find(cassandra_type);
  CHECK(it != types.end()) << "unsupported type: " << cassandra_type;
  return it->second;
}

void SetListFromCassandraRow(const FieldGen& field,
                             const string& builder,
                             const string& row,
                             CodeBuilder& cb) {
  cb.BreakLine() << "{";
  cb.Indent() << "int idx = " << row
              << ".indexOf(\""
              << field.CassandraName() << "\");";
  cb.Newline() << "if (idx != -1 && !row.isNullAt(idx)) {";

  cb.Indent() << field.JavaType() << " value = ";

  GetterFromCassandraRow(field, "row", "idx", cb);

  cb.Newline();
  SetListFromJavaStmt(field, builder, "value", cb);
  cb.OutdentBracket();
  cb.OutdentBracket();
}

void SetFromValue(const FieldGen& field,
                  const string& builder,
                  const string& value,
                  CodeBuilder& cb) {
  cb << builder << ".";
  SetFromJavaStmt(field, value, cb, true);
  cb << ";";
}

void SetFromCassandraRow(const FieldGen& field,
                         const string& builder,
                         const string& row,
                         CodeBuilder& cb) {
  if (field.IsList()) {
    SetListFromCassandraRow(field, builder, row, cb);
  } else {
    cb.BreakLine().Newline() << "{";
    cb.Indent() << "int idx = " << row << ".indexOf(\""
        << PathToField(field) << "\");";
    cb.Newline() << "if (!row.isNullAt(idx)) {";

    cb.Indent() << JavaTypeOfCassandra(field.CassandraType())
        << " value = "
        << row
        << "."
        << GetFromCassandraRow(field.CassandraType())
        << "(idx);";

    cb.Newline();
    SetFromValue(field, "b", "value", cb);
    cb.Outdent() << "}";
    cb.Outdent() << "}";
  }
}

// Create private vars for each list type token that shall be needed.
void WriteTypeTokens(const MessageGen& msg, CodeBuilder& cb) {
  const auto& fields = msg.Fields();

  std::set<string> already_written_types;

  for (const FieldGen* field : fields) {
    if (!field->IsList()) {
      continue;
    }

    string java_type = field->JavaBaseType();
    if (already_written_types.find(java_type) != already_written_types.end()) {
      continue;
    }

    already_written_types.insert(java_type);
    cb.BreakLine() << "private static final com.datastax.spark.connector.types.TypeConverter<java.util.List<"
                   << WrapperTypeOf(java_type) << ">> " << TokenName(java_type)
                   << " = com.datastax.spark.connector.types.TypeConverter.javaListConverter("
                   << "(com.datastax.spark.connector.types.TypeConverter<" << WrapperTypeOf(java_type)
                   << ">) com.datastax.spark.connector.types.TypeConverter.forType("
                   << WrapperTypeOf(java_type) << ".class));";
  }
}
}  // anonymous namespace

string SparkJavaContent(const MessageGen* msg) {
  CodeBuilder cb;
  cb << "// This file is autogenerated by the Structs compiler, DO NOT EDIT MANUALLY";
  cb.BreakLine() << "// @generated : differential looks for 'arobas generated' case sensitive.";
  cb.Newline() << "// https://www.quora.com/Can-I-use-arc-diff-to-exclude-some-files-in-Phabricator";

  cb.BreakLine() << "package " << msg->JavaPkg() << ";";
  cb.BreakLine() << "import com.datastax.spark.connector.japi.CassandraRow;";
  cb.BreakLine();

  cb << "public final class " << msg->JavaClass() << " {";
  cb.Newline();
  WriteTypeTokens(*msg, cb);
  cb.Newline();
  cb.Newline();

  cb.Indent() <<  "public static " << msg->JavaClassOfMessage() << " of(CassandraRow row) throws com.google.protobuf.InvalidProtocolBufferException {";
  cb.Indent() << msg->JavaClassOfMessage() << ".Builder b = " << msg->JavaClassOfMessage() << ".newBuilder();";
   
  for (const FieldGen* field : msg->Fields()) {
    SetFromCassandraRow(*field, "b", "row", cb);
  }

  cb.BreakLine();
  cb.Newline() << "return b.build();";
  cb.Outdent() << "}";
  cb.Outdent() << "}";

  return cb.ToString();
}
}  // namespace structs
